package fr.fleray.couchbase.sample.cblite;
import java.io.File;
import java.net.URI;
import java.util.Date;
import java.util.EnumSet;
import java.util.List;
import java.util.Random;
import java.util.UUID;

import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.DocumentReplication;
import com.couchbase.lite.DocumentReplicationListener;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.MaintenanceType;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.ReplicationFilter;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorActivityLevel;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.Select;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndexItem;

public class GettingStartedFrenchCuisine {

	private static boolean writeNewDocument = true;
	private static final String DB_NAME = "french_cuisine";
	/*
	 * Credentials declared this way purely for expediency in this demo - use OAUTH
	 * in production code
	 */
	private static final String DB_USER = "admin"; // (Bretagne) OR wolfgang (Alsace) marius (PACA)
	private static final String DB_PASS = "password";

	 private static final String SYNC_GATEWAY_URL = "ws://localhost:4984/french_cuisine"; // "ws://52.174.108.107:4984/stime";
//	private static final String SYNC_GATEWAY_URL = "ws://localhost:8080/MyWebSocketProxy23/french_cuisine"; // "ws://52.174.108.107:4984/stime";
	private static final String DB_PATH = new File("").getAbsolutePath() + "/resources";

	public static void main(String[] args) {

		try {
			Random RANDOM = new Random();

			Double randVn = RANDOM.nextDouble() + 1;

			String Prop_Id = "id";
			String Prop_Name = "name";
			String Prop_Price = "price";

			String Prop_Type = "type";
			String searchStringType = "product";

			String Prop_Channels = "channels";
			String channelValue = "PDV_Bretagne";

			// Initialize Couchbase Lite
			CouchbaseLite.init();

			// Get the database (and create it if it doesnâ€™t exist).
			DatabaseConfiguration config = new DatabaseConfiguration();
//			config.setEncryptionKey(encryptionKey)
			config.setDirectory(DB_PATH);
			// config.setEncryptionKey(new EncryptionKey(DB_PASS));
			Database database = new Database(DB_NAME, config);
			
			
			List<String> indexes = database.getIndexes();
			
			if(!indexes.contains("Prop_Type_Index"))
			{
				database.createIndex("Prop_Type_Index",
                        IndexBuilder.valueIndex(ValueIndexItem.property("Prop_Type")));
			}

			System.out.println("List of indexes:");
			for(String ind : indexes) {
				System.out.println(ind);
			}
			
			if (writeNewDocument) {
				// Create a new document (i.e. a record) in the database.
				MutableDocument mutableDoc = new MutableDocument("produit_from_CBL_" + UUID.randomUUID())
						.setString(Prop_Type, "product").setString(Prop_Channels, "PDV_Alsace");

				// Save it to the database.
				database.save(mutableDoc);

				// Update a document.
				mutableDoc = database.getDocument(mutableDoc.getId()).toMutable();
				mutableDoc.setDouble(Prop_Price, randVn);
				mutableDoc.setString(Prop_Name, "produit_local_DB");
				mutableDoc.setString(Prop_Channels, channelValue);
				database.save(mutableDoc);

				Document document = database.getDocument(mutableDoc.getId());
				// Log the document ID (generated by the database) and properties
				System.out.println("Document ID is :: " + document.getId());
				System.out.println("Name " + document.getString(Prop_Name));
				System.out.println("Price " + document.getDouble(Prop_Price));
				System.out.println("Channels " + document.getString(Prop_Channels));
			}

			// Create a query to fetch documents of type "product".
			System.out.println("== Executing Query 1");
			Query query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
					.where(Expression.property(Prop_Type).equalTo(Expression.string(searchStringType)));
			ResultSet result = query.execute();
			System.out.println(
					String.format("Query returned %d rows of type %s", result.allResults().size(), searchStringType));
			
			Expression COUNT = Function.max(Meta.sequence);
			Query maxSequenceQuery = QueryBuilder.select(SelectResult.expression(COUNT))
		          .from(DataSource.database(database))
		          .where(Expression.property(Prop_Type).equalTo(Expression.string(searchStringType))); // your condition (predicate)

			ResultSet execute = maxSequenceQuery.execute();
			
			List<Result> allResults = execute.allResults();
		
			
			Result result2 = allResults.get(0);
			long long1 = result2.getLong(0);
			
//		// Create a query to fetch all documents.
//		System.out.println("== Executing Query 2");
//		Query queryAll = QueryBuilder
//				.select(SelectResult.expression(Meta.id), SelectResult.property(Prop_Name),
//						SelectResult.property(Prop_Price), SelectResult.property(Prop_Type))
//				.from(DataSource.database(database));
//		try {
//			for (Result thisDoc : queryAll.execute()) {
//				numRows++;
//				System.out.println(String.format("%d ... Id: %s is learning: %s version: %.2f type is %s", numRows,
//						thisDoc.getString(Prop_Id), thisDoc.getString(Prop_Name), thisDoc.getDouble(Prop_Price),
//						thisDoc.getString(Prop_Type)));
//			}
//		} catch (CouchbaseLiteException e) {
//			e.printStackTrace();
//		}
//		System.out.println(String.format("Total rows returned by query = %d", numRows));

			Endpoint targetEndpoint = new URLEndpoint(new URI(SYNC_GATEWAY_URL));
			ReplicatorConfiguration replConfig = new ReplicatorConfiguration(database, targetEndpoint);
			replConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

			
//			// additional code to retrueve the channel list associated to a given user
//			
//			/*
//			2 possibilities :  
//				 - if PouchDb is able to use the setChannels equivalent => do it.
//				 - itf not, consider refactoring your code using the CB lite Javascript SDK (ionic) using setChannels method (to be checked) on the replicator
//			*/
//			
//			replConfig.setDocumentIDs(indexes)
//			
//			replConfig.setChannels(arr"whishlist-de");
//
//			replConfig.setChannels("whishlist-de");
//			
//			replCon

			//			replConfig.setPullFilter(new ReplicationFilter() {
//				
//				@Override
//				public boolean filtered(Document arg0, EnumSet<DocumentFlag> arg1) {
//					// TODO Auto-generated method stub
//					return false;
//				}
//			})
			
			
			
			replConfig.setContinuous(false);

			// Add authentication.
			replConfig.setAuthenticator(new BasicAuthenticator(DB_USER, DB_PASS.toCharArray()));
//		
//		List<String> list = new ArrayList<String>();
//		list.add("PDV_Bretagne");
//		replConfig.setChannels(list);
//		
//		if(null != replConfig.getChannels()){
//			for (String channel : replConfig.getChannels()) {
//				System.out.println("A channel for user " + DB_USER + " is : " + channel);
//			}
//		}

			// replConfig.setHeartbeat(1L);
			
			// Create replicator (be sure to hold a reference somewhere that will prevent
			// the Replicator from being GCed)
			Replicator replicator = new Replicator(replConfig);
			

			// Listen to replicator change events.
			replicator.addChangeListener(change -> {
				if (change.getStatus().getError() != null) {
					System.err.println("Error code ::  " + change.getStatus().getError().getCode());
					System.err.println("XXXXXXXXXX ::  " + new Date());
				}
			});

			replicator.addDocumentReplicationListener(new DocumentReplicationListener() {

				@Override
				public void replication(DocumentReplication documentReplication) {
					for (ReplicatedDocument rep : documentReplication.getDocuments()) {
						System.err.println("Document " + rep.getID() + " has been replicated !!");
						
						if(rep.getFlags().contains(DocumentFlag.DELETED)) {
							System.err.println("Document " + rep.getID() + " has been DELETED !!");
							System.err.println("Local purge of the document " + rep.getID() + "... ");
							try {
								database.purge(rep.getID());
							} catch (CouchbaseLiteException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							System.err.println("Local purge of the document " + rep.getID() + "... DONE !");
						}
						else if(rep.getFlags().contains(DocumentFlag.ACCESS_REMOVED)) {
							System.err.println("Document " + rep.getID() + " ACCESS has been removed => probably a channel change for this document !!");
							
							// Decide what to do : here I decide to purge the document since
							// I should not get access to it anymore on my local DB
							
							System.err.println("Local purge of the document " + rep.getID() + "... ");
							try {
								database.purge(rep.getID());
							} catch (CouchbaseLiteException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							System.err.println("Local purge of the document " + rep.getID() + "... DONE !");
						}
					}
				}
			});

			// Start replication.
			replicator.start();

			// Check status of replication and wait till it is completed
			while (replicator.getStatus().getActivityLevel() != ReplicatorActivityLevel.STOPPED) {
				Thread.sleep(5000);
				
				System.out.println("Run compaction...");
				database.performMaintenance(MaintenanceType.COMPACT);
				System.out.println("Run compaction... DONE !");
				
				int numRows = 0;
				// Create a query to fetch all documents.
				System.out.println("== Executing Query 3");
				Query queryAll = QueryBuilder.select(SelectResult.expression(Meta.id), SelectResult.property(Prop_Name),
						SelectResult.property(Prop_Price), SelectResult.property(Prop_Type),
						SelectResult.property(Prop_Channels)).from(DataSource.database(database));
				try {
					for (Result thisDoc : queryAll.execute()) {
						numRows++;
						System.out.println(String.format("%d ... Id: %s is learning: %s version: %.2f type is %s",
								numRows, thisDoc.getString(Prop_Id), thisDoc.getString(Prop_Name),
								thisDoc.getDouble(Prop_Price), thisDoc.getString(Prop_Type)));
					}
				} catch (CouchbaseLiteException e) {
					e.printStackTrace();
				}
				System.out.println(String.format("Total rows returned by query = %d", numRows));
			}

			System.out.println("Finish!");

		} catch (Exception e) {
			System.err.println("Error !! -> Exception" + e);
		}

		System.exit(0);
	}
}